:Namespace embedding

binary_to_quantum_state ← {
    ⍝ Convert binary number to a quantum state.
    ⍝ ⍵: binary number as a vector.
    ⍝ Return a vector state with the qubit representation.
    f ← {⍵ = 0: #.quapl.sng.q0 ⋄ ⍵ = 1: #.quapl.sng.q1}   
    num_qubits  ← ⊃ ⍴ ⍵        
    qubits ← f ¨ ⍵
    register ← #.quapl.circuit.reg num_qubits
    register[;2] ← qubits    
    #.quapl.circuit.thread_reg register
}

decimal_to_binary ← {
    ⍝ Convert a no negative integer to binary number. 
    ⍝ ⍵: takes a decimal number and converted to binary representation. e. g. 34  
    ⍝ Returns a binary number 
    bits ← ⌈/ (1 (⌈ 2⍟(⍵ + 1)) )
    mask ← bits ⍴ 2
    binary ← mask  ⊤ ⍵
    binary
}

decimal_to_quantum_state ← {
    ⍝ Basic Enconding algorithm: that convert a no negative integer to binary. 
    ⍝ ⍵: takes a decimal number and converted to binary representation. e. g. 34  
    ⍝ Returns the vector state with the qubit representation.
    binary_number ← decimal_to_binary ⍵
    vs ← binary_to_quantum_state binary_number  
    vs
}

quantum_associative_memory ← {
    ⍝ Quantum Associative Memory Quam:  Takes n binary numbers and converts to a quantum register
    ⍝ ⍵: a collection of binary numbers. E. g. (0 1 0) (1 1 0) (0 1 1) 
    ⍝ Return a vector state 
    max_length ← ⌈/ ≢¨ ⍵
    padded_vector ← { (max_length - ≢ ⍵) ≠ 0:(((⊃ (max_length - ≢ ⍵)) ⍴ 0) , ⍵) ⋄ (max_length - ≢ ⍵) = 0: ⍵ } ¨ ⍵
    result ← binary_to_quantum_state ¨ padded_vector
    num_states ← ⍴ padded_vector
    ⊃  (÷num_states*÷2)× +/, result
}

amplitude_embedding_encoding ← { 
    ⍝ Amplitud encoding:  Takes a collection of numbers and return a nomalized vector state 
    ⍝ ⍵: collection of  numbers. E. g. amplitude_embedding_encoding ( 1.0, 0.0,¯5.5, 0.0 ) 
    ⍝ return a vector state    
    qubits ← ⊃ ⌈2 ⍟ ⍴ ⍵
    length ← ≢ ⍵ 
    _pad ← ((2*qubits) - length) ⍴ 0
    pad ← { _pad ≢  ⍬: ⍵ , _pad ⋄ _pad ≡ ⍬: ⍵ } ⍵   
    constant_norm ← (+/ pad*2 )*÷2
    vec ← pad ÷ constant_norm
    vec_vertical ← (≢ vec) 1 ⍴ vec
    vec_vertical
}

angle_embedding_encoding ← { 
    ⍝ Angle encoding
    ⍝ ⍺: rotation gate rx , rz, ry 
    ⍝ ⍵: x data to be encoding E. g. ry angle_embedding_encoding (1 2 3 4) 
    ⍝ return a vector state 
    qubits ← ≢ ⍵
    reg← #.quapl.circuit.reg qubits
    rotations  ← ⍺ { ⍺ ≡ 'rx' : (#.quapl.gates.Rx¨⍵)  ⋄ ⍺ ≡ 'ry' : (#.quapl.gates.Ry¨⍵)⋄ ⍺ ≡ 'rz' : (#.quapl.gates.Rz¨⍵) } ⍵
    apply_gate ← {  
        vector ←   ⍵
        gate ← ⊃ vector[1]
        state ←  ⊃ vector[2]
        result ← gate +.×  state
        result
    }
    vector ← (⊂ ¨ rotations) ,¨ (⊂ ¨ reg[;2]) 
    apply_gate ¨ vector
}

is_hermitian ← {
    ⍝ Verify if an input matrix is hermitian
    ⍝ ⍵: matrix
    ⍝ returns: 1 if is hermitian, 0 otherwise
    (⊃1↑⍴⍵) ≢  (2⌷⍴⍵): 0
    ⍵ ≡ #.quapl.mlt.dagger  ⍵
}

norm_square ← {
    ⍝ Conjugate of a vector
    ⍝ ⍵: matrix
    ⍝ returns inner product
    transpose  ←  (#.quapl.mlt.dagger ¨ ⍵)
    vector ← (⊂ ¨ transpose) ,¨ (⊂ ¨ ⍵) 
    apply_gate ← {  (⊃ ⍵[1]) +.× (⊃ ⍵[2])  }
    apply_gate ¨ vector
}

convert_to_helmitian ← {    
    ⍝ Get a matrix and convert it to a helmitian matrix (should be a square matrix)
    ⍝ ⍵: matrix nxm
    ⍝ return a Helmitian matrix
    transpose ← #.quapl.mlt.dagger ⍵ 
    n ← ⊃⍴ ⍵ 
    m ← ⊃⍴ transpose
    z1 ← (n n ⍴ 0 )  ⍝ z1: nxn
    z2 ← (m m ⍴ 0)    ⍝ z2: mxm  
    (z1 , ⍵) ⍪ (transpose , z2)
}

matrix_embedding_encoding ← {
    ⍝ Get a matrix and encode to a hemiltean. ()
    ⍝ ⍵: matrix nxm
    ⍝ return a time evolution operator for an arbitrary Hamiltonian. 
    H ← { is_hermitian ⍵ : ⍵  
          convert_to_helmitian ⍵  
    } ⍵
    i ← ¯1×0J1
    t ← 0.5 
    U ← (*1)*(i×H×t)
    U
}

:EndNamespace
